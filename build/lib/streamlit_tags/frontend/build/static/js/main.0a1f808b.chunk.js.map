{"version":3,"sources":["react-tag-input-componet/classnames.tsx","react-tag-input-componet/tag.tsx","react-autocomplete-hint/utils.ts","react-autocomplete-hint/index.tsx","react-tag-input-componet/index.tsx","keywords.tsx","index.tsx"],"names":["cc","obj","join","tagStyles","css","alignItems","background","borderRadius","display","justifyContent","paddingLeft","button","border","cursor","lineHeight","padding","color","Tag","text","remove","className","style","backgroundColor","dangerouslySetInnerHTML","__html","type","onClick","e","stopPropagation","aria-label","mergeRefs","refs","filteredRefs","filter","Boolean","inst","ref","current","interpolateStyle","styles","attr","subattr","replace","toUpperCase","map","dir","Hint","props","child","React","Children","only","children","toString","toLowerCase","TypeError","options","disableHint","allowTabFill","onFill","onHint","valueModifier","childProps","inputWrapperRef","useRef","mainInputRef","hintWrapperRef","hintRef","useState","unModifiedText","setUnmodifiedText","setText","hint","setHint","match","setMatch","changeEvent","setChangeEvent","useEffect","duplicate","array","tracker","i","length","label","getFirstDuplicateOption","console","warn","inputStyle","window","getComputedStyle","styleHint","setHintTextAndId","x","startsWith","sort","a","b","sortAsc","getMatch","slice","handleOnFill","target","value","onChange","width","fontFamily","fontSize","height","boxSizing","margin","borderStyle","borderWidth","childRef","cloneElement","mainInput","persist","modifiedValue","onBlur","relatedTarget","onFocus","onKeyDown","caretIsAtTextEnd","currentTarget","selectionEnd","key","preventDefault","position","pointerEvents","borderColor","boxShadow","top","left","visibility","whiteSpace","hintCaretPosition","setTimeout","focus","caretPosition","setSelectionRange","outline","caretColor","defaultValue","tabIndex","setup","createElement","RTIContainer","transition","bg","flexWrap","gap","RTIInput","defaultSeprators","TagsInput","name","placeHolder","separators","onExisting","onRemoved","suggestions","maxTags","tags","setTags","remainingLimit","Math","max","onTagRemove","tag","aria-labelledby","placeholder","includes","withStreamlitConnection","args","initialValue","setValue","Streamlit","setFrameHeight","values","setComponentValue","engine","Styletron","ReactDOM","render","StrictMode","theme","LightTheme","document","getElementById"],"mappings":"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","file":"static/js/main.0a1f808b.chunk.js","sourcesContent":["/**\n * A minimal utility to combine classes\n *\n * @export\n * @param {(string[] | string)} obj\n * @returns {string}\n */\nexport default function cc(...obj: (string | number)[]): string {\n  return obj.join(\" \");\n}","import React from \"react\";\nimport { css } from \"goober\";\nimport cc from \"./classnames\";\n\ninterface TagProps {\n  text: string;\n  color: string;\n  remove: any;\n}\n\nconst tagStyles = css({\n  alignItems: \"center\",\n  background: \"var(--rti-tag)\",\n  borderRadius: \"var(--rti-radius)\",\n  display: \"inline-flex\",\n  justifyContent: \"center\",\n  paddingLeft: \"var(--rti-s)\",\n\n  button: {\n    background: \"none\",\n    border: 0,\n    borderRadius: \"50%\",\n    cursor: \"pointer\",\n    lineHeight: \"inherit\",\n    padding: \"0 var(--rti-s)\",\n\n    \"&:hover\": {\n      color: \"var(--rti-tag-remove)\",\n    },\n  },\n});\n\nexport default function Tag({ text, color, remove }: TagProps) {\n  const handleOnRemove = (e: { stopPropagation: () => void; }) => {\n    e.stopPropagation();\n    remove(text);\n  };\n\n  return (\n    <span className={cc(\"rti--tag\", tagStyles)} style={{backgroundColor: color}}>\n      <span dangerouslySetInnerHTML={{ __html: text }}/>\n      <button\n        type=\"button\"\n        onClick={handleOnRemove}\n        aria-label={`remove ${text}`}\n      >\n        &#10005;\n      </button>\n    </span>\n  );\n}\n","import { MutableRefObject, RefCallback } from \"react\";\nimport { IHintOption } from \"./IHintOption\";\n\ntype MutableRef<T> = RefCallback<T> | MutableRefObject<T> | null;\n\nexport function mergeRefs(...refs: Array<MutableRef<HTMLElement | null>>) {\n    const filteredRefs = refs.filter(Boolean);\n\n    return (inst: HTMLElement) => {\n        for (let ref of filteredRefs) {\n            if (typeof ref === 'function') {\n                ref(inst);\n            } else if (ref) {\n                ref.current = inst;\n            }\n        }\n    };\n};\n\n// IE doesn't seem to get the composite computed value (eg: 'padding',\n// 'borderStyle', etc.), so generate these from the individual values.\nexport function interpolateStyle(\n    styles: CSSStyleDeclaration,\n    attr: string,\n    subattr: string = ''\n): string {\n    // Title-case the sub-attribute.\n    if (subattr) {\n        subattr = subattr.replace(subattr[0], subattr[0].toUpperCase());\n    }\n\n    return ['Top', 'Right', 'Bottom', 'Left']\n        // @ts-ignore: (attr + dir + subattr) property cannot be determined at compile time\n        .map((dir) => styles[attr + dir + subattr])\n        .join(' ');\n}\n\nexport function sortAsc<T>(a: T, b: T) {\n    if (a > b) {\n        return 1;\n    }\n    if (a < b) {\n        return -1;\n    }\n    return 0;\n}\n\nexport function getFirstDuplicateOption(array: Array<IHintOption>) {\n    let tracker: { [key: string]: boolean } = {};\n\n    for (let i = 0; i < array.length; i++) {\n        if (tracker[array[i].label]) {\n            return array[i].label;\n        }\n\n        tracker[array[i].label] = true;\n    }\n\n    return null;\n}","import React, {\n    useState,\n    cloneElement,\n    useEffect,\n    useRef,\n    ReactElement\n} from 'react';\nimport { IHintOption } from './IHintOption';\nimport {\n    mergeRefs,\n    interpolateStyle,\n    sortAsc,\n    getFirstDuplicateOption\n} from './utils';\n\nexport interface IHintProps {\n    options: Array<string> | Array<IHintOption>;\n    disableHint?: boolean;\n    children: ReactElement;\n    allowTabFill?: boolean;\n    onFill?(value: string | IHintOption): void;\n    onHint?(value: string | IHintOption | undefined): void;\n    valueModifier?(value: string): string;\n}\n\nexport const Hint: React.FC<IHintProps> = props => {\n    const child = React.Children.only(props.children);\n\n    if (child.type?.toString()?.toLowerCase() !== 'input') {\n        throw new TypeError(`react-autocomplete-hint: 'Hint' only accepts an 'input' element as child.`);\n    }\n\n    const {\n        options,\n        disableHint,\n        allowTabFill,\n        onFill,\n        onHint,\n        valueModifier\n    } = props;\n\n    const childProps = child.props;\n\n    let inputWrapperRef = useRef<HTMLDivElement>(null);\n    let mainInputRef = useRef<HTMLInputElement>(null);\n    let hintWrapperRef = useRef<HTMLSpanElement>(null);\n    let hintRef = useRef<HTMLInputElement>(null);\n    const [unModifiedText, setUnmodifiedText] = useState('');\n    const [text, setText] = useState('');\n    const [hint, setHint] = useState('');\n    const [match, setMatch] = useState<string | IHintOption>();\n    const [changeEvent, setChangeEvent] = useState<React.ChangeEvent<HTMLInputElement>>();\n\n    useEffect(() => {\n        if (typeof options[0] === 'object') {\n            const duplicate = getFirstDuplicateOption(options as Array<IHintOption>);\n            if (duplicate) {\n                console.warn(`react-autocomplete-hint: \"${duplicate}\" occurs more than once and may cause errors. Options should not contain duplicate values!`);\n            }\n        }\n    }, []);\n\n    useEffect(() => {\n        if (disableHint) {\n            return;\n        }\n\n        const inputStyle = mainInputRef.current && window.getComputedStyle(mainInputRef.current);\n        inputStyle && styleHint(inputWrapperRef, hintWrapperRef, hintRef, inputStyle);\n    });\n\n    const getMatch = (text: string) => {\n        if (!text || text === '') {\n            return;\n        }\n\n        if (typeof (options[0]) === 'string') {\n            const match = (options as Array<string>)\n                .filter(x => x.toLowerCase() !== text.toLowerCase() && x.toLowerCase().startsWith(text.toLowerCase()))\n                .sort()[0];\n\n            return match;\n        } else {\n            const match = (options as Array<IHintOption>)\n                .filter(x => x.label.toLowerCase() !== text.toLowerCase() && x.label.toLowerCase().startsWith(text.toLowerCase()))\n                .sort((a, b) => sortAsc(a.label, b.label))[0];\n\n            return match;\n        }\n    };\n\n    const setHintTextAndId = (text: string) => {\n        setText(text);\n\n        const match = getMatch(text);\n        let hint: string;\n\n        if (!match) {\n            hint = '';\n        }\n        else if (typeof match === 'string') {\n            hint = match.slice(text.length);\n        } else {\n            hint = match.label.slice(text.length);\n        }\n\n        setHint(hint);\n        setMatch(match);\n        onHint && onHint(match)\n    }\n\n    const handleOnFill = () => {\n        if (hint !== '' && changeEvent) {\n            changeEvent.target.value = unModifiedText + hint;\n            childProps.onChange && childProps.onChange(changeEvent);\n            setHintTextAndId('');\n\n            onFill && onFill(match!);\n        }\n    };\n\n    const styleHint = (\n        inputWrapperRef: React.RefObject<HTMLDivElement>,\n        hintWrapperRef: React.RefObject<HTMLSpanElement>,\n        hintRef: React.RefObject<HTMLInputElement>,\n        inputStyle: CSSStyleDeclaration) => {\n        if (inputWrapperRef?.current?.style) {\n            inputWrapperRef.current.style.width = inputStyle.width;\n        }\n\n        if (hintWrapperRef?.current?.style) {\n            hintWrapperRef.current.style.fontFamily = inputStyle.fontFamily;\n            hintWrapperRef.current.style.fontSize = inputStyle.fontSize;\n            hintWrapperRef.current.style.width = inputStyle.width;\n            hintWrapperRef.current.style.height = inputStyle.height;\n            hintWrapperRef.current.style.lineHeight = inputStyle.lineHeight;\n            hintWrapperRef.current.style.boxSizing = inputStyle.boxSizing;\n            hintWrapperRef.current.style.margin = interpolateStyle(inputStyle, 'margin');\n            hintWrapperRef.current.style.padding = interpolateStyle(inputStyle, 'padding');\n            hintWrapperRef.current.style.borderStyle = interpolateStyle(inputStyle, 'border', 'style');\n            hintWrapperRef.current.style.borderWidth = interpolateStyle(inputStyle, 'border', 'width');\n        }\n\n        if (hintRef?.current?.style) {\n            hintRef.current.style.fontFamily = inputStyle.fontFamily;\n            hintRef.current.style.fontSize = inputStyle.fontSize;\n            hintRef.current.style.lineHeight = inputStyle.lineHeight;\n        }\n    };\n\n    const onChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n        setChangeEvent(e);\n        e.persist();\n\n        setUnmodifiedText(e.target.value);\n        const modifiedValue = valueModifier ? valueModifier(e.target.value) : e.target.value;\n        setHintTextAndId(modifiedValue);\n\n        childProps.onChange && childProps.onChange(e);\n    };\n\n    const onFocus = (e: React.FocusEvent<HTMLInputElement>) => {\n        setHintTextAndId(e.target.value);\n        childProps.onFocus && childProps.onFocus(e);\n    };\n\n    const onBlur = (e: React.FocusEvent<HTMLInputElement>) => {\n        //Only blur it if the new focus isn't the the hint input\n        if (hintRef?.current !== e.relatedTarget) {\n            setHintTextAndId('');\n            childProps.onBlur && childProps.onBlur(e);\n        }\n    };\n\n    const ARROWRIGHT = 'ArrowRight';\n    const TAB = 'Tab';\n    const onKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {\n        const caretIsAtTextEnd = (() => {\n            // For selectable input types (\"text\", \"search\"), only select the hint if\n            // it's at the end of the input value. For non-selectable types (\"email\",\n            // \"number\"), always select the hint.\n\n            const isNonSelectableType = e.currentTarget.selectionEnd === null;\n            const caretIsAtTextEnd = isNonSelectableType || e.currentTarget.selectionEnd === e.currentTarget.value.length;\n\n            return caretIsAtTextEnd;\n        })();\n\n        if (caretIsAtTextEnd && e.key === ARROWRIGHT) {\n            handleOnFill();\n        } else if (caretIsAtTextEnd && allowTabFill && e.key === TAB && hint !== '') {\n            e.preventDefault();\n            handleOnFill();\n        }\n\n        childProps.onKeyDown && childProps.onKeyDown(e);\n    };\n\n    const onHintClick = (e: React.MouseEvent<HTMLInputElement>) => {\n        const hintCaretPosition = e.currentTarget.selectionEnd || 0;\n\n        // If user clicks the position before the first character of the hint,\n        // move focus to the end of the mainInput text\n        if (hintCaretPosition === 0) {\n            mainInputRef.current?.focus();\n            return;\n        }\n\n        if (!!hint && hint !== '') {\n            handleOnFill();\n            setTimeout(() => {\n                mainInputRef.current?.focus();\n                const caretPosition = text.length + hintCaretPosition;\n                mainInputRef.current?.setSelectionRange(caretPosition, caretPosition);\n            }, 0);\n        }\n    };\n\n    const childRef = cloneElement(child as any).ref;\n    const mainInput = cloneElement(\n        child,\n        {\n            ...childProps,\n            style: {\n                ...childProps.style,\n                boxSizing: 'border-box'\n            },\n            onChange,\n            onBlur,\n            onFocus,\n            onKeyDown,\n            ref: childRef && typeof (childRef) !== 'string'\n                ? mergeRefs(childRef, mainInputRef)\n                : mainInputRef\n        }\n    );\n\n    return (\n        <div\n            className=\"rah-input-wrapper\"\n            style={{\n                position: 'relative'\n            }}>\n            {\n                disableHint\n                    ? child\n                    : (\n                        <>\n                            {mainInput}\n                            <span\n                                className=\"rah-hint-wrapper\"\n                                ref={hintWrapperRef}\n                                style={{\n                                    display: 'flex',\n                                    pointerEvents: 'none',\n                                    backgroundColor: 'transparent',\n                                    borderColor: 'transparent',\n                                    boxSizing: 'border-box',\n                                    boxShadow: 'none',\n                                    color: 'rgba(0, 0, 0, 0.35)',\n                                    position: 'absolute',\n                                    top: 0,\n                                    left: 0,\n                                }}\n                            >\n                                <span\n                                    className='rah-text-filler'\n                                    style={{\n                                        visibility: 'hidden',\n                                        pointerEvents: 'none',\n                                        whiteSpace: 'pre'\n                                    }}\n                                >\n                                    {text}\n                                </span>\n                                <input\n                                    className=\"rah-hint\"\n                                    ref={hintRef}\n                                    onClick={onHintClick}\n                                    style={{\n                                        pointerEvents: !hint || hint === '' ? 'none' : 'visible',\n                                        background: 'transparent',\n                                        width: '100%',\n                                        outline: 'none',\n                                        border: 'none',\n                                        boxShadow: 'none',\n                                        padding: 0,\n                                        margin: 0,\n                                        color: 'rgba(0, 0, 0, 0.50)',\n                                        caretColor: 'transparent'\n                                    }}\n                                    defaultValue={hint}\n                                    tabIndex={-1}\n                                />\n                            </span>\n                        </>\n                    )\n            }\n        </div>\n    );\n}","import { css, setup } from \"goober\";\nimport React, { useEffect, useState } from \"react\";\n\nimport cc from \"./classnames\";\nimport Tag from \"./tag\";\nimport {Hint} from \"../react-autocomplete-hint\";\n\n\n\nexport interface IHintOption {\n    id: string | number;\n    label: string;\n}\n\nexport interface TagsInputProps {\n  name?: string;\n  placeHolder?: string;\n  value: string[];\n  color: string;\n  onChange?: (tags: string[]) => void;\n  suggestions: Array<string> | Array<IHintOption>;\n  onBlur?: any;\n  separators?: string[];\n  onExisting?: (tag: string) => void;\n  onRemoved?: (tag: string) => void;\n  maxTags: number;\n}\n\n// initialize goober once\nsetup(React.createElement);\n\nconst RTIContainer = css({\n  \"--rtiBg\": \"#fff\",\n  \"--rtiBorder\": \"#ccc\",\n  \"--rtiMain\": \"#3182ce\",\n  \"--rtiRadius\": \"0.375rem\",\n  \"--rtiS\": \"0.5rem\",\n  \"--rtiTag\": \"#edf2f7\",\n  \"--rtiTagRemove\": \"#e53e3e\",\n  '--rti-bg': '#fff',\n  '--rti-border': '#ccc',\n  '--rti-main': '#3182ce',\n  '--rti-radius': '0.375rem',\n  '--rti-s': '0.5rem',\n  '--rti-tag': '#edf2f7',\n  '--rti-tag-remove': '#e53e3e',\n\n\n  \"*\": {\n    boxSizing: \"border-box\",\n    transition: \"all 0.2s ease\",\n  },\n\n  alignItems: \"center\",\n  bg: \"var(--rti-bg)\",\n  border: \"1px solid var(--rti-border)\",\n  borderRadius: \"var(--rti-radius)\",\n  display: \"flex\",\n  flexWrap: \"wrap\",\n  gap: \"var(--rti-s)\",\n  lineHeight: 1.4,\n  padding: \"var(--rti-s)\",\n\n  \"&:focus-within\": {\n    borderColor: \"var(--rti-main)\",\n    boxShadow: \"var(--rti-main) 0px 0px 0px 1px\",\n  },\n});\n\nconst RTIInput = css({\n  border: 0,\n  outline: 0,\n  fontSize: \"inherit\",\n  lineHeight: \"inherit\",\n  width: \"200%\",\n});\n\nconst defaultSeprators = [\"Enter\"];\n\nexport const TagsInput = ({\n  name,\n  placeHolder,\n  value,\n  color,\n  onChange,\n  onBlur,\n  separators,\n  onExisting,\n  onRemoved,\n  suggestions,\n  maxTags\n}: TagsInputProps) => {\n  let [tags, setTags] = useState(value || []);\n\n  useEffect(() => {\n    onChange && onChange(tags);\n  }, [tags]);\n\n  if (maxTags >= 0) {\n      let remainingLimit = Math.max(maxTags, 0)\n      tags = tags.slice(0, remainingLimit)\n  }\n\n  const handleOnKeyUp = (e) => {\n    e.stopPropagation();\n\n    const text = e.target.value;\n\n    if (e.key === \"Backspace\" && tags.length && !text) {\n      setTags(tags.slice(0, -1));\n    }\n\n\n    if (text && (separators || defaultSeprators).includes(e.key)) {\n      if (tags.includes(text)) {\n        onExisting && onExisting(text);\n        return;\n      }\n      setTags([...tags, text]);\n      e.target.value = \"\";\n      e.preventDefault();\n    }\n  };\n\n  const onTagRemove = (text: string) => {\n    setTags(tags.filter(tag => tag !== text));\n    onRemoved && onRemoved(text);\n  };\n\n  return (\n    <div aria-labelledby={name} className={cc(\"rti--container\", RTIContainer)}>\n      {tags.map(tag => (\n        <Tag key={tag} text={tag} color={color} remove={onTagRemove} />\n      ))}\n\n      <Hint options={suggestions} allowTabFill={true}>\n          <input\n              className={cc(\"rti--input\", RTIInput)}\n              type=\"text\"\n              name={name}\n              placeholder={placeHolder}\n              onKeyDown={handleOnKeyUp}\n              onBlur={onBlur}\n      />\n    </Hint>\n    </div>\n  );\n};\n","import React,{ useEffect, useState, ReactElement, ReactNode }  from \"react\"\nimport { ComponentProps, Streamlit, withStreamlitConnection } from \"streamlit-component-lib\"\nimport { TagsInput } from \"./react-tag-input-componet\";\nimport \"./styles.css\";\n\ninterface PythonArgs {\n  label: string\n  text: string\n  color: string\n  initialValue: string[]\n  suggestions: string[]\n  maxTags: number\n}\n\nconst Custom_keywords = (props: ComponentProps):ReactElement => {\n  // Destructure using Typescript interface\n  // This ensures typing validation for received props from Python\n  let { label, text, color, initialValue, suggestions, maxTags}: PythonArgs = props.args\n  const [value, setValue] = useState(initialValue)\n\n  const onSubmit = (values: string[]) => {\n    setValue(values)\n    Streamlit.setComponentValue((values))\n  }\n  useEffect(() => Streamlit.setFrameHeight())\n  return (\n    <div>\n        <TagsInput\n        value={value}\n        color={color}\n        onChange= {(value) =>  onSubmit(value)}\n        name={label}\n        placeHolder={text}\n        suggestions={suggestions}\n        maxTags={maxTags}\n      />\n    </div>\n  )\n}\n\nexport default withStreamlitConnection(Custom_keywords)\n","import React from \"react\"\nimport ReactDOM from \"react-dom\"\nimport Custom_keywords from \"./keywords\"\n\n// Lots of import to define a Styletron engine and load the light theme of baseui\n// @ts-ignore\nimport { Client as Styletron } from \"styletron-engine-atomic\"\nimport { Provider as StyletronProvider } from \"styletron-react\"\nimport { LightTheme, BaseProvider } from \"baseui\"\n\nconst engine = new Styletron()\n\n// Wrap your CustomSlider with the baseui them\nReactDOM.render(\n  <React.StrictMode>\n    <StyletronProvider value={engine}>\n      <BaseProvider theme={LightTheme} children={<Custom_keywords/>} />\n    </StyletronProvider>\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n)\n"],"sourceRoot":""}